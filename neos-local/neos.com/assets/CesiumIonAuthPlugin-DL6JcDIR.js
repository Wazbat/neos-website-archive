import{G as Rt,h as St,C as Ut}from"./GeometryClipper-DDKqlNfA.js";import{t as Pt}from"./TilesRenderer-Dt06WWnf.js";import{T as It}from"./EPSGTilesPlugin-DJF9gzHX.js";import{bh as Ct,ak as Et,e as Mt,h as Nt,l as Q,al as ot,p as Vt,J as Ot,X as Gt,bi as zt,w as Bt,M as nt,ao as Dt,V as pt}from"./three.module-CQU0seT4.js";import{L as Ht}from"./readMagicBytes-ReGFEf36.js";import{E as kt}from"./Ellipsoid-BKsGN9dG.js";import{a as Ft}from"./TiledImageSource-Dter0Emb.js";import{P as jt}from"./TMSImageSource-BwMpBOyS.js";const mt="https://tile.googleapis.com/v1/createSession";class qt{get isMapTilesSession(){return this.authURL===mt}constructor(t={}){const{apiToken:e,sessionOptions:s=null,autoRefreshToken:n=!1}=t;this.apiToken=e,this.autoRefreshToken=n,this.authURL=mt,this.sessionToken=null,this.sessionOptions=s,this._tokenRefreshPromise=null}async fetch(t,e){this.sessionToken===null&&this.isMapTilesSession&&this.refreshToken(e),await this._tokenRefreshPromise;const s=new URL(t);s.searchParams.set("key",this.apiToken),this.sessionToken&&s.searchParams.set("session",this.sessionToken);let n=await fetch(s,e);return n.status>=400&&n.status<=499&&this.autoRefreshToken&&(await this.refreshToken(e),this.sessionToken&&s.searchParams.set("session",this.sessionToken),n=await fetch(s,e)),this.sessionToken===null&&!this.isMapTilesSession?n.json().then(r=>(this.sessionToken=ft(r),r)):n}refreshToken(t){if(this._tokenRefreshPromise===null){const e=new URL(this.authURL);e.searchParams.set("key",this.apiToken);const s={...t};this.isMapTilesSession&&(s.method="POST",s.body=JSON.stringify(this.sessionOptions),s.headers=s.headers||{},s.headers={...s.headers,"Content-Type":"application/json"}),this._tokenRefreshPromise=fetch(e,s).then(n=>{if(!n.ok)throw new Error(`GoogleCloudAuth: Failed to load data with error code ${n.status}`);return n.json()}).then(n=>(this.sessionToken=ft(n),this._tokenRefreshPromise=null,n))}return this._tokenRefreshPromise}}function ft(y){if("session"in y)return y.session;{let t=null;const e=y.root;return Pt(e,s=>{if(s.content&&s.content.uri){const[,n]=s.content.uri.split("?");return t=new URLSearchParams(n).get("session"),!0}return!1}),t}}class Xt{constructor(){this.creditsCount={}}_adjustAttributions(t,e){const s=this.creditsCount,n=t.split(/;/g);for(let r=0,u=n.length;r<u;r++){const L=n[r];L in s||(s[L]=0),s[L]+=e?1:-1,s[L]<=0&&delete s[L]}}addAttributions(t){this._adjustAttributions(t,!0)}removeAttributions(t){this._adjustAttributions(t,!1)}toString(){return Object.entries(this.creditsCount).sort((e,s)=>{const n=e[1];return s[1]-n}).map(e=>e[0]).join("; ")}}const Qt="https://tile.googleapis.com/v1/3dtiles/root.json";class Yt{constructor({apiToken:t,sessionOptions:e=null,autoRefreshToken:s=!1,logoUrl:n=null,useRecommendedSettings:r=!0}){this.name="GOOGLE_CLOUD_AUTH_PLUGIN",this.apiToken=t,this.useRecommendedSettings=r,this.logoUrl=n,this.auth=new qt({apiToken:t,autoRefreshToken:s,sessionOptions:e}),this.tiles=null,this._visibilityChangeCallback=null,this._attributionsManager=new Xt,this._logoAttribution={value:"",type:"image",collapsible:!1},this._attribution={value:"",type:"string",collapsible:!0}}init(t){const{useRecommendedSettings:e,auth:s}=this;t.resetFailedTiles(),t.rootURL==null&&(t.rootURL=Qt),s.sessionOptions||(s.authURL=t.rootURL),e&&!s.isMapTilesSession&&(t.errorTarget=20),this.tiles=t,this._visibilityChangeCallback=({tile:n,visible:r})=>{var L,l;const u=((l=(L=n.cached.metadata)==null?void 0:L.asset)==null?void 0:l.copyright)||"";r?this._attributionsManager.addAttributions(u):this._attributionsManager.removeAttributions(u)},t.addEventListener("tile-visibility-change",this._visibilityChangeCallback)}getAttributions(t){this.tiles.visibleTiles.size>0&&(this.logoUrl&&(this._logoAttribution.value=this.logoUrl,t.push(this._logoAttribution)),this._attribution.value=this._attributionsManager.toString(),t.push(this._attribution))}dispose(){this.tiles.removeEventListener("tile-visibility-change",this._visibilityChangeCallback)}async fetchData(t,e){return this.auth.fetch(t,e)}}function lt(y){return y>>1^-(y&1)}class $t extends Ht{constructor(...t){super(...t),this.fetchOptions.header={Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9"}}loadAsync(...t){const{fetchOptions:e}=this;return e.header=e.header||{},e.header.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",e.header.Accept+=";extensions=octvertexnormals-watermask-metadata",super.loadAsync(...t)}parse(t){let e=0;const s=new DataView(t),n=()=>{const a=s.getFloat64(e,!0);return e+=8,a},r=()=>{const a=s.getFloat32(e,!0);return e+=4,a},u=()=>{const a=s.getUint32(e,!0);return e+=4,a},L=()=>{const a=s.getUint8(e);return e+=1,a},l=(a,O)=>{const H=new O(t,e,a);return e+=a*O.BYTES_PER_ELEMENT,H},m={center:[n(),n(),n()],minHeight:r(),maxHeight:r(),sphereCenter:[n(),n(),n()],sphereRadius:n(),horizonOcclusionPoint:[n(),n(),n()]},p=u(),d=l(p,Uint16Array),E=l(p,Uint16Array),T=l(p,Uint16Array),h=new Float32Array(p),b=new Float32Array(p),v=new Float32Array(p);let g=0,w=0,z=0;const i=32767;for(let a=0;a<p;++a)g+=lt(d[a]),w+=lt(E[a]),z+=lt(T[a]),h[a]=g/i,b[a]=w/i,v[a]=z/i;const f=p>65536,R=f?Uint32Array:Uint16Array;f?e=Math.ceil(e/4)*4:e=Math.ceil(e/2)*2;const _=u(),V=l(_*3,R);let q=0;for(var Y=0;Y<V.length;++Y){const a=V[Y];V[Y]=q-a,a===0&&++q}const J=(a,O)=>b[O]-b[a],F=(a,O)=>-J(a,O),j=(a,O)=>h[a]-h[O],o=(a,O)=>-j(a,O),c=u(),k=l(c,R);k.sort(J);const I=u(),x=l(I,R);x.sort(j);const M=u(),C=l(M,R);C.sort(F);const S=u(),U=l(S,R);U.sort(o);const A={westIndices:k,southIndices:x,eastIndices:C,northIndices:U},N={};for(;e<s.byteLength;){const a=L(),O=u();if(a===1){const H=l(p*2,Uint8Array),B=new Float32Array(p*3);for(let X=0;X<p;X++){let Z=H[2*X+0]/255*2-1,$=H[2*X+1]/255*2-1;const it=1-(Math.abs(Z)+Math.abs($));if(it<0){const dt=Z;Z=(1-Math.abs($))*gt(dt),$=(1-Math.abs(dt))*gt($)}const at=Math.sqrt(Z*Z+$*$+it*it);B[3*X+0]=Z/at,B[3*X+1]=$/at,B[3*X+2]=it/at}N.octvertexnormals={extensionId:a,normals:B}}else if(a===2){const H=O===1?1:256,B=l(H*H,Uint8Array);N.watermask={extensionId:a,mask:B,size:H}}else if(a===4){const H=u(),B=l(H,Uint8Array),X=new TextDecoder().decode(B);N.metadata={extensionId:a,json:JSON.parse(X)}}}return{header:m,indices:V,vertexData:{u:h,v:b,height:v},edgeIndices:A,extensions:N}}}function gt(y){return y<0?-1:1}const bt=new Q,rt=new Dt,P=new Q,K=new Q;class Zt extends $t{constructor(t=Ct){super(),this.manager=t,this.ellipsoid=new kt,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI}parse(t){const{ellipsoid:e,solid:s,skirtLength:n,smoothSkirtNormals:r,minLat:u,maxLat:L,minLon:l,maxLon:m}=this,{header:p,indices:d,vertexData:E,edgeIndices:T,extensions:h}=super.parse(t),b=new Et,v=new Mt,g=new Nt(b,v);g.position.set(...p.center);const w="octvertexnormals"in h,z=E.u.length,i=[],f=[],R=[],_=[];let V=0,q=0;for(let o=0;o<z;o++)J(o,P),F(P.x,P.y,P.z,K),f.push(P.x,P.y),i.push(...K);for(let o=0,c=d.length;o<c;o++)R.push(d[o]);if(w){const o=h.octvertexnormals.normals;for(let c=0,k=o.length;c<k;c++)_.push(o[c])}if(b.addGroup(V,d.length,q),V+=d.length,q++,s){const o=i.length/3;for(let c=0;c<z;c++)J(c,P),F(P.x,P.y,P.z,K,-n),f.push(P.x,P.y),i.push(...K);for(let c=d.length-1;c>=0;c--)R.push(d[c]+o);if(w){const c=h.octvertexnormals.normals;for(let k=0,I=c.length;k<I;k++)_.push(-c[k])}b.addGroup(V,d.length,q),V+=d.length,q++}if(n>0){const{westIndices:o,eastIndices:c,southIndices:k,northIndices:I}=T;let x;const M=j(o);x=i.length/3,f.push(...M.uv),i.push(...M.positions);for(let A=0,N=M.indices.length;A<N;A++)R.push(M.indices[A]+x);const C=j(c);x=i.length/3,f.push(...C.uv),i.push(...C.positions);for(let A=0,N=C.indices.length;A<N;A++)R.push(C.indices[A]+x);const S=j(k);x=i.length/3,f.push(...S.uv),i.push(...S.positions);for(let A=0,N=S.indices.length;A<N;A++)R.push(S.indices[A]+x);const U=j(I);x=i.length/3,f.push(...U.uv),i.push(...U.positions);for(let A=0,N=U.indices.length;A<N;A++)R.push(U.indices[A]+x);w&&(_.push(...M.normals),_.push(...C.normals),_.push(...S.normals),_.push(...U.normals)),b.addGroup(V,d.length,q),V+=d.length,q++}for(let o=0,c=i.length;o<c;o+=3)i[o+0]-=p.center[0],i[o+1]-=p.center[1],i[o+2]-=p.center[2];const Y=i.length/3>65535?new Uint32Array(R):new Uint16Array(R);if(b.setIndex(new ot(Y,1,!1)),b.setAttribute("position",new ot(new Float32Array(i),3,!1)),b.setAttribute("uv",new ot(new Float32Array(f),2,!1)),w&&b.setAttribute("normal",new ot(new Float32Array(_),3,!1)),"watermask"in h){const{mask:o,size:c}=h.watermask,k=new Uint8Array(2*c*c);for(let x=0,M=o.length;x<M;x++){const C=o[x]===255?0:255;k[2*x+0]=C,k[2*x+1]=C}const I=new Vt(k,c,c,Ot,Gt);I.flipY=!0,I.minFilter=zt,I.magFilter=Bt,I.needsUpdate=!0,v.roughnessMap=I}return g.userData.minHeight=p.minHeight,g.userData.maxHeight=p.maxHeight,"metadata"in h&&(g.userData.metadata=h.metadata.json),g;function J(o,c){return c.x=E.u[o],c.y=E.v[o],c.z=E.height[o],c}function F(o,c,k,I,x=0){const M=nt.lerp(p.minHeight,p.maxHeight,k),C=nt.lerp(l,m,o),S=nt.lerp(u,L,c);return e.getCartographicToPosition(S,C,M+x,I),I}function j(o){const c=[],k=[],I=[],x=[],M=[];for(let U=0,A=o.length;U<A;U++)J(o[U],P),c.push(P.x,P.y),I.push(P.x,P.y),F(P.x,P.y,P.z,K),k.push(...K),F(P.x,P.y,P.z,K,-n),x.push(...K);const C=o.length-1;for(let U=0;U<C;U++){const A=U,N=U+1,a=U+o.length,O=U+o.length+1;M.push(A,a,N),M.push(N,a,O)}let S=null;if(w){const U=(k.length+x.length)/3;if(r){S=new Array(U*3);const A=h.octvertexnormals.normals,N=S.length/2;for(let a=0,O=U/2;a<O;a++){const H=o[a],B=3*a,X=A[3*H+0],Z=A[3*H+1],$=A[3*H+2];S[B+0]=X,S[B+1]=Z,S[B+2]=$,S[N+B+0]=X,S[N+B+1]=Z,S[N+B+2]=$}}else{S=[],rt.a.fromArray(k,0),rt.b.fromArray(x,0),rt.c.fromArray(k,3),rt.getNormal(bt);for(let A=0;A<U;A++)S.push(...bt)}}return{uv:[...c,...I],positions:[...k,...x],indices:M,normals:S}}}}const yt={},Jt=new Q,ht=new Q,ct=new Q,Kt=new Q,Wt=new Q,D=new Q,et=new Q,G=new pt,W=new pt,Lt=new pt;class te extends Rt{constructor(){super(),this.ellipsoid=new kt,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI,this.attributeList=["position","normal","uv"]}clipToQuadrant(t,e,s){const{solid:n,skirtLength:r,ellipsoid:u,smoothSkirtNormals:L}=this;this.clearSplitOperations(),this.addSplitOperation(xt("x"),!e),this.addSplitOperation(xt("y"),!s);let l,m;const p=t.geometry.groups[0],d=this.getClippedData(t,p);if(this.adjustVertices(d,t.position,0),n){l={index:d.index.slice().reverse(),attributes:{}};for(const f in d.attributes)l.attributes[f]=d.attributes[f].slice();const i=l.attributes.normal;if(i)for(let f=0;f<i.length;f+=3)i[f+0]*=-1,i[f+1]*=-1,i[f+2]*=-1;this.adjustVertices(l,t.position,-r)}if(r>0){m={index:[],attributes:{position:[],normal:[],uv:[]}};let i=0;const f={},R=(F,j,o)=>{const c=St(...F,...o,...j);c in f||(f[c]=i,i++,m.attributes.position.push(...F),m.attributes.normal.push(...o),m.attributes.uv.push(...j)),m.index.push(f[c])},_=d.index,V=d.attributes.uv,q=d.attributes.position,Y=d.attributes.normal,J=d.index.length/3;for(let F=0;F<J;F++){const j=3*F;for(let o=0;o<3;o++){const c=(o+1)%3,k=_[j+o],I=_[j+c];if(G.fromArray(V,k*2),W.fromArray(V,I*2),G.x===W.x&&(G.x===0||G.x===.5||G.x===1)||G.y===W.y&&(G.y===0||G.y===.5||G.y===1)){ht.fromArray(q,k*3),ct.fromArray(q,I*3);const x=ht,M=ct,C=Kt.copy(ht),S=Wt.copy(ct);D.copy(C).add(t.position),u.getPositionToNormal(D,D),C.addScaledVector(D,-r),D.copy(S).add(t.position),u.getPositionToNormal(D,D),S.addScaledVector(D,-r),L&&Y?(D.fromArray(Y,k*3),et.fromArray(Y,I*3)):(D.subVectors(x,M),et.subVectors(x,C).cross(D).normalize(),D.copy(et)),R(M,W,et),R(x,G,D),R(C,G,D),R(M,W,et),R(C,G,D),R(S,W,et)}}}}const E=d.index.length,T=d;if(l){const{index:i,attributes:f}=l,R=T.attributes.position.length/3;for(let _=0,V=i.length;_<V;_++)T.index.push(i[_]+R);for(const _ in d.attributes)T.attributes[_].push(...f[_])}if(m){const{index:i,attributes:f}=m,R=T.attributes.position.length/3;for(let _=0,V=i.length;_<V;_++)T.index.push(i[_]+R);for(const _ in d.attributes)T.attributes[_].push(...f[_])}const h=e?0:-.5,b=s?0:-.5,v=T.attributes.uv;for(let i=0,f=v.length;i<f;i+=2)v[i]=(v[i]+h)*2,v[i+1]=(v[i+1]+b)*2;const g=this.constructMesh(T.attributes,T.index,t);g.userData.minHeight=t.userData.minHeight,g.userData.maxHeight=t.userData.maxHeight;let w=0,z=0;return g.geometry.addGroup(z,E,w),z+=E,w++,l&&(g.geometry.addGroup(z,l.index.length,w),z+=l.index.length,w++),m&&(g.geometry.addGroup(z,m.index.length,w),z+=m.index.length,w++),g}adjustVertices(t,e,s){const{ellipsoid:n,minLat:r,maxLat:u,minLon:L,maxLon:l}=this,{attributes:m,vertexIsClipped:p}=t,d=m.position,E=m.uv,T=d.length/3;for(let h=0;h<T;h++){const b=G.fromArray(E,h*2);p&&p[h]&&(Math.abs(b.x-.5)<1e-10&&(b.x=.5),Math.abs(b.y-.5)<1e-10&&(b.y=.5),G.toArray(E,h*2));const v=nt.lerp(r,u,b.y),g=nt.lerp(L,l,b.x),w=Jt.fromArray(d,h*3).add(e);n.getPositionToCartographic(w,yt),n.getCartographicToPosition(v,g,yt.height+s,w),w.sub(e),w.toArray(d,h*3)}}}function xt(y){return(t,e,s,n,r)=>{const u=t.attributes.uv;return G.fromBufferAttribute(u,e),W.fromBufferAttribute(u,s),Lt.fromBufferAttribute(u,n),G[y]*r.x+W[y]*r.y+Lt[y]*r.z-.5}}const At=Symbol("TILE_X"),Tt=Symbol("TILE_Y"),st=Symbol("TILE_LEVEL"),tt=Symbol("TILE_AVAILABLE"),vt=1e4,_t=new Q;function ee(y,t,e,s){if(y&&t<y.length){const n=y[t];for(let r=0,u=n.length;r<u;r++){const{startX:L,startY:l,endX:m,endY:p}=n[r];if(e>=L&&e<=m&&s>=l&&s<=p)return!0}}return!1}function wt(y){const{available:t=null,maxzoom:e=null}=y;return e===null?t.length-1:e}function se(y){const{metadataAvailability:t=-1}=y;return t}function ut(y,t){const e=y[st],s=se(t),n=wt(t);return e<n&&s!==-1&&e%s===0}function ne(y,t,e,s,n){return n.tiles[0].replace(/{\s*z\s*}/g,e).replace(/{\s*x\s*}/g,y).replace(/{\s*y\s*}/g,t).replace(/{\s*version\s*}/g,s)}class ie{constructor(t={}){const{useRecommendedSettings:e=!0,skirtLength:s=null,smoothSkirtNormals:n=!0,solid:r=!1}=t;this.name="QUANTIZED_MESH_PLUGIN",this.priority=-1e3,this.tiles=null,this.layer=null,this.useRecommendedSettings=e,this.skirtLength=s,this.smoothSkirtNormals=n,this.solid=r,this.attribution=null,this.tiling=new Ft,this.projection=new jt}init(t){t.fetchOptions.headers=t.fetchOptions.headers||{},t.fetchOptions.headers.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",this.useRecommendedSettings&&(t.errorTarget=2),this.tiles=t}loadRootTileSet(){const{tiles:t}=this;let e=new URL("layer.json",new URL(t.rootURL,location.href));return t.invokeAllPlugins(s=>e=s.preprocessURL?s.preprocessURL(e,null):e),t.invokeOnePlugin(s=>s.fetchData&&s.fetchData(e,this.tiles.fetchOptions)).then(s=>s.json()).then(s=>{this.layer=s;const{projection:n="EPSG:4326",extensions:r=[],attribution:u="",available:L=null}=s,{tiling:l,tiles:m,projection:p}=this;u&&(this.attribution={value:u,type:"string",collapsible:!0}),r.length>0&&(m.fetchOptions.headers.Accept+=`;extensions=${r.join("-")}`),p.setScheme(n);const{tileCountX:d,tileCountY:E}=p;l.setProjection(p),l.generateLevels(wt(s)+1,d,E);const T=[];for(let v=0;v<d;v++){const g=this.createChild(0,v,0,L);g&&T.push(g)}const h={asset:{version:"1.1"},geometricError:1/0,root:{refine:"REPLACE",geometricError:1/0,boundingVolume:{region:[...this.tiling.getContentBounds(),-1e4,vt]},children:T,[tt]:L,[st]:-1}};let b=m.rootURL;return m.invokeAllPlugins(v=>b=v.preprocessURL?v.preprocessURL(b,null):b),m.preprocessTileSet(h,b),h})}parseToMesh(t,e,s,n){const{skirtLength:r,solid:u,smoothSkirtNormals:L,tiles:l}=this,m=l.ellipsoid;let p;if(s==="quantized_tile_split"){const h=new URL(n).searchParams,b=h.get("left")==="true",v=h.get("bottom")==="true",g=new te;g.ellipsoid.copy(m),g.solid=u,g.smoothSkirtNormals=L,g.skirtLength=r===null?e.geometricError:r;const[w,z,i,f]=e.parent.boundingVolume.region;g.minLat=z,g.maxLat=f,g.minLon=w,g.maxLon=i,p=g.clipToQuadrant(e.parent.cached.scene,b,v)}else if(s==="terrain"){const h=new Zt(l.manager);h.ellipsoid.copy(m),h.solid=u,h.smoothSkirtNormals=L,h.skirtLength=r===null?e.geometricError:r;const[b,v,g,w]=e.boundingVolume.region;h.minLat=v,h.maxLat=w,h.minLon=b,h.maxLon=g,p=h.parse(t)}else return;const{minHeight:d,maxHeight:E,metadata:T}=p.userData;return e.boundingVolume.region[4]=d,e.boundingVolume.region[5]=E,e.cached.boundingVolume.setRegionData(m,...e.boundingVolume.region),T&&("geometricerror"in T&&(e.geometricError=T.geometricerror),ut(e,this.layer)&&"available"in T&&e.children.length===0&&(e[tt]=[...new Array(e[st]+1).fill(null),...T.available])),this.expandChildren(e),p}getAttributions(t){this.attribution&&t.push(this.attribution)}createChild(t,e,s,n){const{tiles:r,layer:u,tiling:L,projection:l}=this,m=r.ellipsoid,p=n===null&&t===0||ee(n,t,e,s),d=ne(e,s,t,1,u),E=[...L.getTileBounds(e,s,t),-1e4,vt],[,T,,h,,b]=E,v=T>0!=h>0?0:Math.min(Math.abs(T),Math.abs(h));m.getCartographicToPosition(v,0,b,_t),_t.z=0;const g=l.tileCountX,i=Math.max(...m.radius)*2*Math.PI*.25/(65*g)/2**t,f={[tt]:null,[st]:t,[At]:e,[Tt]:s,refine:"REPLACE",geometricError:i,boundingVolume:{region:E},content:p?{uri:d}:null,children:[]};return ut(f,u)||(f[tt]=n),f}expandChildren(t){const e=t[st],s=t[At],n=t[Tt],r=t[tt];let u=!1;for(let L=0;L<2;L++)for(let l=0;l<2;l++){const m=this.createChild(e+1,2*s+L,2*n+l,r);m.content!==null?(t.children.push(m),u=!0):(t.children.push(m),m.content={uri:`tile.quantized_tile_split?bottom=${l===0}&left=${L===0}`})}u||(t.children.length=0)}fetchData(t,e){if(/quantized_tile_split/.test(t))return new ArrayBuffer}disposeTile(t){ut(t,this.layer)&&(t[tt]=null),tt in t&&(t.children.forEach(e=>{this.tiles.processNodeQueue.remove(e)}),t.children.length=0,t.__childrenProcessed=0)}}class de{get apiToken(){return this.auth.apiToken}set apiToken(t){this.auth.apiToken=t}get autoRefreshToken(){return this.auth.autoRefreshToken}set autoRefreshToken(t){this.auth.autoRefreshToken=t}constructor({apiToken:t,assetId:e=null,autoRefreshToken:s=!1,useRecommendedSettings:n=!0}){this.name="CESIUM_ION_AUTH_PLUGIN",this.auth=new Ut({apiToken:t,autoRefreshToken:s}),this.assetId=e,this.autoRefreshToken=s,this.useRecommendedSettings=n,this.tiles=null,this._tileSetVersion=-1,this._attributions=[]}init(t){this.assetId!==null&&(t.rootURL=`https://api.cesium.com/v1/assets/${this.assetId}/endpoint`),this.tiles=t,this.auth.authURL=t.rootURL,t.resetFailedTiles()}loadRootTileSet(){return this.auth.refreshToken().then(t=>(this._initializeFromAsset(t),this.tiles.invokeOnePlugin(e=>e!==this&&e.loadRootTileSet&&e.loadRootTileSet()))).catch(t=>{this.tiles.dispatchEvent({type:"load-error",tile:null,error:t,url:this.auth.authURL})})}preprocessURL(t){return t=new URL(t),/^http/.test(t.protocol)&&this._tileSetVersion!=-1&&t.searchParams.set("v",this._tileSetVersion),t.toString()}fetchData(t,e){return this.tiles.getPluginByName("GOOGLE_CLOUD_AUTH_PLUGIN")!==null?null:this.auth.fetch(t,e)}getAttributions(t){this.tiles.visibleTiles.size>0&&t.push(...this._attributions)}_initializeFromAsset(t){const e=this.tiles;if("externalType"in t){const s=new URL(t.options.url);e.rootURL=t.options.url,e.registerPlugin(new Yt({apiToken:s.searchParams.get("key"),autoRefreshToken:this.autoRefreshToken,useRecommendedSettings:this.useRecommendedSettings}))}else{t.type==="TERRAIN"&&e.getPluginByName("QUANTIZED_MESH_PLUGIN")===null?e.registerPlugin(new ie({useRecommendedSettings:this.useRecommendedSettings})):t.type==="IMAGERY"&&e.getPluginByName("TMS_TILES_PLUGIN")===null&&e.registerPlugin(new It({useRecommendedSettings:this.useRecommendedSettings,shape:"ellipsoid"})),e.rootURL=t.url;const s=new URL(t.url);s.searchParams.has("v")&&this._tileSetVersion===-1&&(this._tileSetVersion=s.searchParams.get("v")),t.attributions&&(this._attributions=t.attributions.map(n=>({value:n.html,type:"html",collapsible:n.collapsible})))}}}export{de as C};
//# sourceMappingURL=CesiumIonAuthPlugin-DL6JcDIR.js.map
