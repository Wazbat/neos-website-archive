import{M as a,aK as P,y as C,bp as j}from"./three.module-CQU0seT4.js";function v(...L){return L.join("_")}class M{constructor(){this.cache={},this.count=0,this.cachedBytes=0,this.active=0}fetchItem(){}disposeItem(){}getMemoryUsage(t){return 0}setData(...t){const{cache:i}=this,e=t.pop(),o=v(...t);if(o in i)throw new Error(`DataCache: "${o}" is already present.`);return this.cache[o]={abortController:new AbortController,result:e,count:1,bytes:this.getMemoryUsage(e)},this.count++,this.cachedBytes+=this.cache[o].bytes,e}lock(...t){const{cache:i}=this,e=v(...t);if(e in i)i[e].count++;else{const o=new AbortController,n={abortController:o,result:null,count:1,bytes:0};this.active++,n.result=this.fetchItem(t,o.signal),n.result instanceof Promise?n.result.then(s=>(n.result=s,n.bytes=this.getMemoryUsage(s),this.cachedBytes+=n.bytes,s)).finally(()=>{this.active--}).catch(s=>{}):(this.active--,n.bytes=this.getMemoryUsage(n.result),this.cachedBytes+=n.bytes),this.cache[e]=n,this.count++}return i[e].result}release(...t){const i=v(...t);this.releaseViaFullKey(i)}get(...t){const{cache:i}=this,e=v(...t);return e in i&&i[e].count>0?i[e].result:null}has(...t){const{cache:i}=this;return v(...t)in i}dispose(){const{cache:t}=this;for(const i in t){const{abortController:e}=t[i];e.abort(),this.releaseViaFullKey(i,!0)}this.cache={}}releaseViaFullKey(t,i=!1){const{cache:e}=this;if(t in e&&e[t].count>0){const o=e[t];if(o.count--,o.count===0||i){const n=()=>{if(e[t]!==o)return;const{result:s,abortController:r}=o;r.abort(),s instanceof Promise?s.then(c=>{this.disposeItem(c),this.count--,this.cachedBytes-=o.bytes}).catch(()=>{}):(this.disposeItem(s),this.count--,this.cachedBytes-=o.bytes),delete e[t]};i?n():queueMicrotask(()=>{o.count===0&&n()})}return!0}throw new Error("DataCache: Attempting to release key that does not exist")}}class b{get levelCount(){return this._levels.length}get maxLevel(){return this.levelCount-1}get minLevel(){const t=this._levels;for(let i=0;i<t.length;i++)if(t[i]!==null)return i;return-1}get contentBounds(){var t;return this._contentBounds??((t=this.projection)==null?void 0:t.getBounds())??[0,0,1,1]}get aspectRatio(){const{pixelWidth:t,pixelHeight:i}=this.getLevel(this.maxLevel);return t/i}constructor(){this.flipY=!1,this.pixelOverlap=0,this._contentBounds=null,this.projection=null,this._levels=[]}setLevel(t,i={}){const e=this._levels;for(;e.length<t;)e.push(null);const{tilePixelWidth:o=256,tilePixelHeight:n=256,tileCountX:s=2**t,tileCountY:r=2**t,tileBounds:c=null}=i,{pixelWidth:l=o*s,pixelHeight:m=n*r}=i;e[t]={tilePixelWidth:o,tilePixelHeight:n,pixelWidth:l,pixelHeight:m,tileCountX:s,tileCountY:r,tileBounds:c}}generateLevels(t,i,e,o={}){const{minLevel:n=0,tilePixelWidth:s=256,tilePixelHeight:r=256}=o,c=t-1,{pixelWidth:l=s*i*2**c,pixelHeight:m=r*e*2**c}=o;for(let h=n;h<t;h++){const p=t-h-1,d=Math.ceil(l*2**-p),g=Math.ceil(m*2**-p),f=Math.ceil(d/s),B=Math.ceil(g/r);this.setLevel(h,{tilePixelWidth:s,tilePixelHeight:r,pixelWidth:d,pixelHeight:g,tileCountX:f,tileCountY:B})}}getLevel(t){return this._levels[t]}setContentBounds(t,i,e,o){this._contentBounds=[t,i,e,o]}setProjection(t){this.projection=t}getTileAtPoint(t,i,e,o=!1){const{flipY:n}=this,{tileCountX:s,tileCountY:r,tileBounds:c}=this.getLevel(e),l=1/s,m=1/r;if(o||([t,i]=this.toNormalizedPoint(t,i)),c){const d=this.toNormalizedRange(c);t=a.mapLinear(t,d[0],d[2],0,1),i=a.mapLinear(i,d[1],d[3],0,1)}const h=Math.floor(t/l);let p=Math.floor(i/m);return n&&(p=r-1-p),[h,p]}getTilesInRange(t,i,e,o,n,s=!1){[t,i,e,o]=this.clampToContentBounds([t,i,e,o],s);const r=this.getTileAtPoint(t,i,n,s),c=this.getTileAtPoint(e,o,n,s);this.flipY&&([r[1],c[1]]=[c[1],r[1]]);const{tileCountX:l,tileCountY:m}=this.getLevel(n),[h,p]=r,[d,g]=c;return d<0||g<0||h>=l||p>=m?[0,0,-1,-1]:[a.clamp(h,0,l-1),a.clamp(p,0,m-1),a.clamp(d,0,l-1),a.clamp(g,0,m-1)]}getTileExists(t,i,e){const[o,n,s,r]=this.contentBounds,[c,l,m,h]=this.getTileBounds(t,i,e);return!(c>=m||l>=h)&&c<=s&&l<=r&&m>=o&&h>=n}getContentBounds(t=!1){const{projection:i}=this,e=[...this.contentBounds];return i&&t&&(e[0]=i.convertLongitudeToProjection(e[0]),e[1]=i.convertLatitudeToProjection(e[1]),e[2]=i.convertLongitudeToProjection(e[2]),e[3]=i.convertLatitudeToProjection(e[3])),e}getTileContentUVBounds(t,i,e){const[o,n,s,r]=this.getTileBounds(t,i,e,!0,!0),[c,l,m,h]=this.getTileBounds(t,i,e,!0,!1);return[a.mapLinear(o,c,m,0,1),a.mapLinear(n,l,h,0,1),a.mapLinear(s,c,m,0,1),a.mapLinear(r,l,h,0,1)]}getTileBounds(t,i,e,o=!1,n=!0){const{flipY:s,pixelOverlap:r,projection:c}=this,{tilePixelWidth:l,tilePixelHeight:m,pixelWidth:h,pixelHeight:p,tileBounds:d}=this.getLevel(e);let g=l*t-r,f=m*i-r,B=g+l+r*2,T=f+m+r*2;if(g=Math.max(g,0),f=Math.max(f,0),B=Math.min(B,h),T=Math.min(T,p),g=g/h,B=B/h,f=f/p,T=T/p,s){const x=(T-f)/2,y=1-(f+T)/2;f=y-x,T=y+x}let u=[g,f,B,T];if(d){const x=this.toNormalizedRange(d);u[0]=a.mapLinear(u[0],0,1,x[0],x[2]),u[2]=a.mapLinear(u[2],0,1,x[0],x[2]),u[1]=a.mapLinear(u[1],0,1,x[1],x[3]),u[3]=a.mapLinear(u[3],0,1,x[1],x[3])}return n&&(u=this.clampToProjectionBounds(u,!0)),c&&!o&&(u[0]=c.convertProjectionToLongitude(u[0]),u[1]=c.convertProjectionToLatitude(u[1]),u[2]=c.convertProjectionToLongitude(u[2]),u[3]=c.convertProjectionToLatitude(u[3])),u}toNormalizedPoint(t,i){const{projection:e}=this,o=[t,i];return this.projection&&(o[0]=e.convertLongitudeToProjection(o[0]),o[1]=e.convertLatitudeToProjection(o[1])),o}toNormalizedRange(t){return[...this.toNormalizedPoint(t[0],t[1]),...this.toNormalizedPoint(t[2],t[3])]}toCartographicPoint(t,i){const{projection:e}=this,o=[t,i];if(this.projection)o[0]=e.convertProjectionToLongitude(o[0]),o[1]=e.convertProjectionToLatitude(o[1]);else throw new Error("TilingScheme: Projection not available.");return o}toCartographicRange(t){return[...this.toCartographicPoint(t[0],t[1]),...this.toCartographicPoint(t[2],t[3])]}clampToContentBounds(t,i=!1){const e=[...t],[o,n,s,r]=this.getContentBounds(i);return e[0]=a.clamp(e[0],o,s),e[1]=a.clamp(e[1],n,r),e[2]=a.clamp(e[2],o,s),e[3]=a.clamp(e[3],n,r),e}clampToProjectionBounds(t,i=!1){const e=[...t],{projection:o}=this;let n;i||!o?n=[0,0,1,1]:n=o.getBounds();const[s,r,c,l]=n;return e[0]=a.clamp(e[0],s,c),e[1]=a.clamp(e[1],r,l),e[2]=a.clamp(e[2],s,c),e[3]=a.clamp(e[3],r,l),e}}class Y extends M{constructor(){super(),this.tiling=new b,this.fetchOptions={},this.fetchData=(...t)=>fetch(...t)}init(){}async processBufferToTexture(t){const i=new Blob([t]),e=await createImageBitmap(i,{premultiplyAlpha:"none",colorSpaceConversion:"none",imageOrientation:"flipY"}),o=new P(e);return o.generateMipmaps=!1,o.colorSpace=C,o.needsUpdate=!0,o}getMemoryUsage(t){const{TextureUtils:i}=j;if(!i)return 0;const{format:e,type:o,image:n,generateMipmaps:s}=t,{width:r,height:c}=n,l=i.getByteLength(r,c,e,o);return s?l*4/3:l}fetchItem(t,i){const e={...this.fetchOptions,signal:i},o=this.getUrl(...t);return this.fetchData(o,e).then(n=>n.arrayBuffer()).then(n=>this.processBufferToTexture(n))}disposeItem(t){t.dispose(),t.image instanceof ImageBitmap&&t.image.close()}getUrl(...t){}}export{Y as T,b as a};
//# sourceMappingURL=TiledImageSource-Dter0Emb.js.map
