import{I as K,T as N,a as Z,b as H}from"./ImageFormatPlugin-gd2xpo9t.js";import{l as b,M as d,b9 as Q,d as tt,V as et}from"./three.module-CQU0seT4.js";import{P as it,T as st,X as ot}from"./TMSImageSource-BwMpBOyS.js";import{T as nt}from"./TiledImageSource-Dter0Emb.js";const W=new b,_=new b;function rt(p,i,t){const e=t+1e-5;let s=i+1e-5;Math.abs(s)>Math.PI/2&&(s=s-1e-5),p.getCartographicToPosition(i,t,0,W),p.getCartographicToPosition(s,t,0,_);const o=W.distanceTo(_)/1e-5;return p.getCartographicToPosition(i,e,0,_),[W.distanceTo(_)/1e-5,o]}const at=30,ct=15,X=new b,F=new b,u=new et,R=new tt;class Y extends K{get projection(){return this.tiling.projection}constructor(i={}){const{shape:t="planar",endCaps:n=!0,...e}=i;super(e),this.shape=t,this.endCaps=n}async parseToMesh(i,t,...n){const e=await super.parseToMesh(i,t,...n),{shape:s,projection:o,tiles:r,tiling:c}=this;if(s==="ellipsoid"){const a=r.ellipsoid,h=t[N],T=t[Z],f=t[H],[M,g,B,x]=t.boundingVolume.region,v=Math.ceil((x-g)*d.RAD2DEG*.25),w=Math.ceil((B-M)*d.RAD2DEG*.25),L=Math.max(ct,v),C=Math.max(at,w),I=new Q(1,1,C,L),[V,y,j,E]=c.getTileBounds(T,f,h,!0,!0),P=c.getTileContentUVBounds(T,f,h),{position:U,normal:$,uv:G}=I.attributes,k=U.count;t.cached.boundingVolume.getSphere(R);for(let m=0;m<k;m++){X.fromBufferAttribute(U,m),u.fromBufferAttribute(G,m);const D=o.convertProjectionToLongitude(d.mapLinear(u.x,0,1,V,j));let l=o.convertProjectionToLatitude(d.mapLinear(u.y,0,1,y,E));if(o.isMercator&&this.endCaps&&(E===1&&u.y===1&&(l=Math.PI/2),y===0&&u.y===0&&(l=-Math.PI/2)),o.isMercator&&u.y!==0&&u.y!==1){const S=o.convertProjectionToLatitude(1),A=1/L,q=d.mapLinear(u.y-A,0,1,g,x),J=d.mapLinear(u.y+A,0,1,g,x);l>S&&q<S&&(l=S),l<-S&&J>-S&&(l=-S)}a.getCartographicToPosition(l,D,0,X).sub(R.center),a.getCartographicToNormal(l,D,F);const z=d.mapLinear(o.convertLongitudeToProjection(D),V,j,P[0],P[2]),O=d.mapLinear(o.convertLatitudeToProjection(l),y,E,P[1],P[3]);G.setXY(m,z,O),U.setXYZ(m,...X),$.setXYZ(m,...F)}e.geometry=I,e.position.copy(R.center)}return e}createBoundingVolume(i,t,n){if(this.shape==="ellipsoid"){const{tiling:e,endCaps:s}=this,o=n===-1,r=o?e.getContentBounds(!0):e.getTileBounds(i,t,n,!0,!0),c=o?e.getContentBounds():e.getTileBounds(i,t,n,!1,!0);return s&&(r[3]===1&&(c[3]=Math.PI/2),r[1]===0&&(c[1]=-Math.PI/2)),{region:[...c,-1,1]}}else return super.createBoundingVolume(i,t,n)}createChild(...i){const t=super.createChild(...i),{shape:n,projection:e,tiling:s}=this;if(t&&n==="ellipsoid"){const o=t[N],r=t[Z],c=t[H];if(o===-1)return t.geometricError=1e50,parent;const[a,h,T,f]=s.getTileBounds(r,c,o,!0),{tilePixelWidth:M,tilePixelHeight:g}=s.getLevel(o),B=(T-a)/M,x=(f-h)/g,[,v,w,L]=s.getTileBounds(r,c,o),C=v>0!=L>0?0:Math.min(Math.abs(v),Math.abs(L)),I=e.convertLatitudeToProjection(C),V=e.getLongitudeDerivativeAtProjection(a),y=e.getLatitudeDerivativeAtProjection(I),[j,E]=rt(this.tiles.ellipsoid,C,w),P=Math.max(B*V*j,x*y*E);t.geometricError=P}return t}}class lt extends nt{constructor(i={}){super();const{capabilities:t=null,layer:n=null,tileMatrixSet:e=null,style:s=null,url:o=null,dimensions:r={}}=i;this.capabilities=t,this.layer=n,this.tileMatrixSet=e,this.style=s,this.dimensions=r,this.url=o}getUrl(i,t,n){return this.url.replace(/{\s*TileMatrix\s*}/gi,n).replace(/{\s*TileCol\s*}/gi,i).replace(/{\s*TileRow\s*}/gi,t)}init(){const{tiling:i,dimensions:t,capabilities:n}=this;let{layer:e,tileMatrixSet:s,style:o,url:r}=this;e?typeof e=="string"&&(e=n.layers.find(a=>a.identifier===e)):e=n.layers[0],s?typeof s=="string"&&(s=e.tileMatrixSets.find(a=>a.identifier===s)):s=e.tileMatrixSets[0],o||(o=e.styles.find(a=>a.isDefault).identifier),r||(r=e.resourceUrls[0].template);const c=s.supportedCRS.includes("4326")?"EPSG:4326":"EPSG:3857";i.flipY=!0,i.setProjection(new it(c)),i.setContentBounds(...i.projection.getBounds()),s.tileMatrices.forEach((a,h)=>{const{tileWidth:T,tileHeight:f,matrixWidth:M,matrixHeight:g}=a;i.setLevel(h,{tilePixelWidth:T,tilePixelHeight:f,tileCountX:M||i.projection.tileCountX*2**h,tileCountY:g||i.projection.tileCountY*2**h,tileBounds:a.bounds})}),r=r.replace(/{\s*TileMatrixSet\s*}/g,s.identifier).replace(/{\s*Style\s*}/g,o);for(const a in t)r=r.replace(new RegExp(`{\\s*${a}\\s*}`),t[a]);return e.dimensions.forEach(a=>{r=r.replace(new RegExp(`{\\s*${a.identifier}\\s*}`),a.defaultValue)}),this.url=r,Promise.resolve()}}class gt extends Y{constructor(i={}){const{levels:t,tileDimension:n,projection:e,bounds:s,url:o,...r}=i;super(r),this.name="XYZ_TILES_PLUGIN",this.imageSource=new ot({url:o,levels:t,tileDimension:n,projection:e,bounds:s})}}class mt extends Y{constructor(i={}){const{url:t,...n}=i;super(n),this.name="TMS_TILES_PLUGIN",this.imageSource=new st({url:t})}}class Tt extends Y{constructor(i={}){const{capabilities:t,layer:n,tileMatrixSet:e,style:s,dimensions:o,...r}=i;super(r),this.name="WTMS_TILES_PLUGIN",this.imageSource=new lt({capabilities:t,layer:n,tileMatrixSet:e,style:s,dimensions:o})}}export{mt as T,Tt as W,gt as X};
//# sourceMappingURL=EPSGTilesPlugin-DJF9gzHX.js.map
