import{ak as q,al as S,h as D,M as U,ao as W,r as A}from"./three.module-CQU0seT4.js";class j{constructor(e={}){const{apiToken:i,autoRefreshToken:t=!1}=e;this.apiToken=i,this.autoRefreshToken=t,this.authURL=null,this._tokenRefreshPromise=null,this._bearerToken=null}async fetch(e,i){await this._tokenRefreshPromise;const t={...i};t.headers=t.headers||{},t.headers={...t.headers,Authorization:this._bearerToken};const s=await fetch(e,t);return s.status>=400&&s.status<=499&&this.autoRefreshToken?(await this.refreshToken(i),t.headers.Authorization=this._bearerToken,fetch(e,t)):s}refreshToken(e){if(this._tokenRefreshPromise===null){const i=new URL(this.authURL);i.searchParams.set("access_token",this.apiToken),this._tokenRefreshPromise=fetch(i,e).then(t=>{if(!t.ok)throw new Error(`CesiumIonAuthPlugin: Failed to load data with error code ${t.status}`);return t.json()}).then(t=>(this._bearerToken=`Bearer ${t.accessToken}`,this._tokenRefreshPromise=null,t))}return this._tokenRefreshPromise}}const p=0,y=["a","b","c"],a=new A,B=new A,O=new A,L=new A;class J{constructor(){this.attributeList=null,this.splitOperations=[],this.trianglePool=new X}forEachSplitPermutation(e){const{splitOperations:i}=this,t=(s=0)=>{if(s>=i.length){e();return}i[s].keepPositive=!0,t(s+1),i[s].keepPositive=!1,t(s+1)};t()}addSplitOperation(e,i=!0){this.splitOperations.push({callback:e,keepPositive:i})}clearSplitOperations(){this.splitOperations.length=0}clipObject(e){const i=e.clone(),t=[];return i.traverse(s=>{s.isMesh&&(s.geometry=this.clip(s).geometry,(s.geometry.index?s.geometry.index.count/3:s.attributes.position.count/3)===0&&t.push(s))}),t.forEach(s=>{s.removeFromParent()}),i}clip(e,i=null){const t=this.getClippedData(e,i);return this.constructMesh(t.attributes,t.index,e)}getClippedData(e,i=null,t={}){const{trianglePool:s,splitOperations:l,attributeList:n}=this,c=e.geometry,r=c.attributes.position,o=c.index;let u=0;const h={};t.index=t.index||[],t.vertexIsClipped=t.vertexIsClipped||[],t.attributes=t.attributes||{};for(const f in c.attributes){if(n!==null){if(n instanceof Function&&!n(f))continue;if(Array.isArray(n)&&!n.includes(f))continue}t.attributes[f]=[]}let d=0,V=o?o.count:r.count;i!==null&&(d=i.start,V=i.count);for(let f=d,P=d+V;f<P;f+=3){let m=f+0,g=f+1,w=f+2;o&&(m=o.getX(m),g=o.getX(g),w=o.getX(w));const C=s.get();C.initFromIndices(m,g,w);let T=[C];for(let k=0;k<l.length;k++){const{keepPositive:_,callback:F}=l[k],R=[];for(let E=0;E<T.length;E++){const v=T[E],{indices:x,barycoord:I}=v;v.clipValues.a=F(c,x.a,x.b,x.c,I.a,e.matrixWorld),v.clipValues.b=F(c,x.a,x.b,x.c,I.b,e.matrixWorld),v.clipValues.c=F(c,x.a,x.b,x.c,I.c,e.matrixWorld),this.splitTriangle(v,!_,R)}T=R}for(let k=0,_=T.length;k<_;k++){const F=T[k];G(F,c)}s.reset()}return t;function G(f,P){for(let m=0;m<3;m++){const g=f.getVertexHash(m,P);g in h||(h[g]=u,u++,f.getVertexData(m,P,t.attributes),t.vertexIsClipped.push(f.clipValues[y[m]]===p));const w=h[g];t.index.push(w)}}}constructMesh(e,i,t){const s=t.geometry,l=new q,n=e.position.length/3>65535?new Uint32Array(i):new Uint16Array(i);l.setIndex(new S(n,1,!1));for(const r in e){const o=s.getAttribute(r),u=new o.array.constructor(e[r]),h=new S(u,o.itemSize,o.normalized);h.gpuType=o.gpuType,l.setAttribute(r,h)}const c=new D(l,t.material.clone());return c.position.copy(t.position),c.quaternion.copy(t.quaternion),c.scale.copy(t.scale),c}splitTriangle(e,i,t){const{trianglePool:s}=this,l=[],n=[],c=[];for(let r=0;r<3;r++){const o=y[r],u=y[(r+1)%3],h=e.clipValues[o],d=e.clipValues[u];(h<p!=d<p||h===p)&&(l.push(r),n.push([o,u]),h===d?c.push(0):c.push(U.mapLinear(p,h,d,0,1)))}if(l.length!==2)Math.min(e.clipValues.a,e.clipValues.b,e.clipValues.c)<p===i&&t.push(e);else if(l.length===2){const r=s.get().initFromTriangle(e),o=s.get().initFromTriangle(e),u=s.get().initFromTriangle(e);(l[0]+1)%3===l[1]?(r.lerpVertexFromEdge(e,n[0][0],n[0][1],c[0],"a"),r.copyVertex(e,n[0][1],"b"),r.lerpVertexFromEdge(e,n[1][0],n[1][1],c[1],"c"),r.clipValues.a=p,r.clipValues.c=p,o.lerpVertexFromEdge(e,n[0][0],n[0][1],c[0],"a"),o.copyVertex(e,n[1][1],"b"),o.copyVertex(e,n[0][0],"c"),o.clipValues.a=p,u.lerpVertexFromEdge(e,n[0][0],n[0][1],c[0],"a"),u.lerpVertexFromEdge(e,n[1][0],n[1][1],c[1],"b"),u.copyVertex(e,n[1][1],"c"),u.clipValues.a=p,u.clipValues.b=p):(r.lerpVertexFromEdge(e,n[0][0],n[0][1],c[0],"a"),r.lerpVertexFromEdge(e,n[1][0],n[1][1],c[1],"b"),r.copyVertex(e,n[0][0],"c"),r.clipValues.a=p,r.clipValues.b=p,o.lerpVertexFromEdge(e,n[0][0],n[0][1],c[0],"a"),o.copyVertex(e,n[0][1],"b"),o.lerpVertexFromEdge(e,n[1][0],n[1][1],c[1],"c"),o.clipValues.a=p,o.clipValues.c=p,u.copyVertex(e,n[0][1],"a"),u.copyVertex(e,n[1][0],"b"),u.lerpVertexFromEdge(e,n[1][0],n[1][1],c[1],"c"),u.clipValues.c=p);let d,V;d=Math.min(r.clipValues.a,r.clipValues.b,r.clipValues.c),V=d<p,V===i&&t.push(r),d=Math.min(o.clipValues.a,o.clipValues.b,o.clipValues.c),V=d<p,V===i&&t.push(o),d=Math.min(u.clipValues.a,u.clipValues.b,u.clipValues.c),V=d<p,V===i&&t.push(u)}}}class X{constructor(){this.pool=[],this.index=0}get(){if(this.index>=this.pool.length){const i=new H;this.pool.push(i)}const e=this.pool[this.index];return this.index++,e}reset(){this.index=0}}class H{constructor(){this.indices={a:-1,b:-1,c:-1},this.clipValues={a:-1,b:-1,c:-1},this.barycoord=new W}getVertexHash(e,i){const{barycoord:t,indices:s}=this,l=y[e],n=t[l];if(n.x===1)return s[y[0]];if(n.y===1)return s[y[1]];if(n.z===1)return s[y[2]];{const{attributes:c}=i;let r="";for(const o in c){const u=c[o];switch(M(u,s.a,s.b,s.c,n,a),(o==="normal"||o==="tangent"||o==="bitangent")&&a.normalize(),u.itemSize){case 4:r+=z(a.x,a.y,a.z,a.w);break;case 3:r+=z(a.x,a.y,a.z);break;case 2:r+=z(a.x,a.y);break;case 1:r+=z(a.x);break}r+="|"}return r}}getVertexData(e,i,t){const{barycoord:s,indices:l}=this,n=y[e],c=s[n],{attributes:r}=i;for(const o in r){if(!t[o])continue;const u=r[o],h=t[o];switch(M(u,l.a,l.b,l.c,c,a),(o==="normal"||o==="tangent"||o==="bitangent")&&a.normalize(),u.itemSize){case 4:h.push(a.x,a.y,a.z,a.w);break;case 3:h.push(a.x,a.y,a.z);break;case 2:h.push(a.x,a.y);break;case 1:h.push(a.x);break}}}initFromTriangle(e){return this.initFromIndices(e.indices.a,e.indices.b,e.indices.c)}initFromIndices(e,i,t){return this.indices.a=e,this.indices.b=i,this.indices.c=t,this.clipValues.a=-1,this.clipValues.b=-1,this.clipValues.c=-1,this.barycoord.a.set(1,0,0),this.barycoord.b.set(0,1,0),this.barycoord.c.set(0,0,1),this}lerpVertexFromEdge(e,i,t,s,l){this.clipValues[l]=U.lerp(e.clipValues[i],e.clipValues[t],s),this.barycoord[l].lerpVectors(e.barycoord[i],e.barycoord[t],s)}copyVertex(e,i,t){this.clipValues[t]=e.clipValues[i],this.barycoord[t].copy(e.barycoord[i])}}function M(b,e,i,t,s,l){switch(B.fromBufferAttribute(b,e),O.fromBufferAttribute(b,i),L.fromBufferAttribute(b,t),l.set(0,0,0,0).addScaledVector(B,s.x).addScaledVector(O,s.y).addScaledVector(L,s.z),b.itemSize){case 3:a.w=0;break;case 2:a.w=0,a.z=0;break;case 1:a.w=0,a.z=0,a.y=0;break}return l}function z(...b){let t="";for(let s=0,l=b.length;s<l;s++)t+=~~(b[s]*1e5+.5),s!==l-1&&(t+="_");return t}export{j as C,J as G,z as h};
//# sourceMappingURL=GeometryClipper-DDKqlNfA.js.map
