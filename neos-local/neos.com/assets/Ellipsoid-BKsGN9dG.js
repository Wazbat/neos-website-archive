import{M as R,as as B,l as m,k as D,d as Q,ae as tt,b8 as et}from"./three.module-CQU0seT4.js";const E=new B,k=new m,it={};function ot(r){const{x:e,y:t,z:i}=r;r.x=i,r.y=e,r.z=t}function st(r){return-(r-Math.PI/2)}function H(r){return-r+Math.PI/2}function nt(r,e,t={}){return E.theta=e,E.phi=H(r),k.setFromSpherical(E),E.setFromVector3(k),t.lat=st(E.phi),t.lon=E.theta,t}function I(r,e="E",t="W"){const i=r<0?t:e;r=Math.abs(r);const o=~~r,s=(r-o)*60,n=~~s,h=~~((s-n)*60);return`${o}° ${n}' ${h}" ${i}`}function lt(r,e,t=!1){const i=nt(r,e,it);let o,s;return t?(o=`${(R.RAD2DEG*i.lat).toFixed(4)}°`,s=`${(R.RAD2DEG*i.lon).toFixed(4)}°`):(o=I(R.RAD2DEG*i.lat,"N","S"),s=I(R.RAD2DEG*i.lon,"E","W")),`${o} ${s}`}const X=new B,d=new m,l=new m,b=new m,p=new D,u=new D,Y=new D,C=new Q,c=new et,Z=new m,G=new m,V=new m,M=new m,L=new tt,rt=1e-12,at=.1,z=0,W=1,f=2;class ht{constructor(e=1,t=1,i=1){this.name="",this.radius=new m(e,t,i)}intersectRay(e,t){return p.makeScale(...this.radius).invert(),C.center.set(0,0,0),C.radius=1,L.copy(e).applyMatrix4(p),L.intersectSphere(C,t)?(p.makeScale(...this.radius),t.applyMatrix4(p),t):null}getEastNorthUpFrame(e,t,i,o){return i.isMatrix4&&(o=i,i=0,console.warn('Ellipsoid: The signature for "getEastNorthUpFrame" has changed.')),this.getEastNorthUpAxes(e,t,Z,G,V),this.getCartographicToPosition(e,t,i,M),o.makeBasis(Z,G,V).setPosition(M)}getOrientedEastNorthUpFrame(e,t,i,o,s,n,a){return this.getObjectFrame(e,t,i,o,s,n,a,z)}getObjectFrame(e,t,i,o,s,n,a,h=f){return this.getEastNorthUpFrame(e,t,i,p),c.set(s,n,-o,"ZXY"),a.makeRotationFromEuler(c).premultiply(p),h===W?(c.set(Math.PI/2,0,0,"XYZ"),u.makeRotationFromEuler(c),a.multiply(u)):h===f&&(c.set(-Math.PI/2,0,Math.PI,"XYZ"),u.makeRotationFromEuler(c),a.multiply(u)),a}getCartographicFromObjectFrame(e,t,i=f){return i===W?(c.set(-Math.PI/2,0,0,"XYZ"),u.makeRotationFromEuler(c).premultiply(e)):i===f?(c.set(-Math.PI/2,0,Math.PI,"XYZ"),u.makeRotationFromEuler(c).premultiply(e)):u.copy(e),M.setFromMatrixPosition(u),this.getPositionToCartographic(M,t),this.getEastNorthUpFrame(t.lat,t.lon,0,p).invert(),u.premultiply(p),c.setFromRotationMatrix(u,"ZXY"),t.azimuth=-c.z,t.elevation=c.x,t.roll=c.y,t}getEastNorthUpAxes(e,t,i,o,s,n=M){this.getCartographicToPosition(e,t,0,n),this.getCartographicToNormal(e,t,s),i.set(-n.y,n.x,0).normalize(),o.crossVectors(s,i).normalize()}getAzElRollFromRotationMatrix(e,t,i,o,s=z){return console.warn('Ellipsoid: "getAzElRollFromRotationMatrix" is deprecated. Use "getCartographicFromObjectFrame", instead.'),this.getCartographicToPosition(e,t,0,M),Y.copy(i).setPosition(M),this.getCartographicFromObjectFrame(Y,o,s),delete o.height,delete o.lat,delete o.lon,o}getRotationMatrixFromAzElRoll(e,t,i,o,s,n,a=z){return console.warn('Ellipsoid: "getRotationMatrixFromAzElRoll" function has been deprecated. Use "getObjectFrame", instead.'),this.getObjectFrame(e,t,0,i,o,s,n,a),n.setPosition(0,0,0),n}getFrame(e,t,i,o,s,n,a,h=z){return console.warn('Ellipsoid: "getFrame" function has been deprecated. Use "getObjectFrame", instead.'),this.getObjectFrame(e,t,n,i,o,s,a,h)}getCartographicToPosition(e,t,i,o){this.getCartographicToNormal(e,t,d);const s=this.radius;l.copy(d),l.x*=s.x**2,l.y*=s.y**2,l.z*=s.z**2;const n=Math.sqrt(d.dot(l));return l.divideScalar(n),o.copy(l).addScaledVector(d,i)}getPositionToCartographic(e,t){this.getPositionToSurfacePoint(e,l),this.getPositionToNormal(e,d);const i=b.subVectors(e,l);return t.lon=Math.atan2(d.y,d.x),t.lat=Math.asin(d.z),t.height=Math.sign(i.dot(e))*i.length(),t}getCartographicToNormal(e,t,i){return X.set(1,H(e),t),i.setFromSpherical(X).normalize(),ot(i),i}getPositionToNormal(e,t){const i=this.radius;return t.copy(e),t.x/=i.x**2,t.y/=i.y**2,t.z/=i.z**2,t.normalize(),t}getPositionToSurfacePoint(e,t){const i=this.radius,o=1/i.x**2,s=1/i.y**2,n=1/i.z**2,a=e.x*e.x*o,h=e.y*e.y*s,S=e.z*e.z*n,O=a+h+S,w=Math.sqrt(1/O),P=l.copy(e).multiplyScalar(w);if(O<at)return isFinite(w)?t.copy(P):null;const J=b.set(P.x*o*2,P.y*s*2,P.z*n*2);let g=(1-w)*e.length()/(.5*J.length()),v=0,_,U,y,F,x,T,A,N,j,q,$;do{g-=v,y=1/(1+g*o),F=1/(1+g*s),x=1/(1+g*n),T=y*y,A=F*F,N=x*x,j=T*y,q=A*F,$=N*x,_=a*T+h*A+S*N-1,U=a*j*o+h*q*s+S*$*n;const K=-2*U;v=_/K}while(Math.abs(_)>rt);return t.set(e.x*y,e.y*F,e.z*x)}calculateHorizonDistance(e,t){const i=this.calculateEffectiveRadius(e);return Math.sqrt(2*i*t+t**2)}calculateEffectiveRadius(e){const t=this.radius.x,o=1-this.radius.z**2/t**2,s=e*R.DEG2RAD,n=Math.sin(s)**2;return t/Math.sqrt(1-o*n)}getPositionElevation(e){this.getPositionToSurfacePoint(e,l);const t=b.subVectors(e,l);return Math.sign(t.dot(e))*t.length()}copy(e){return this.radius.copy(e.radius),this}clone(){return new this.constructor().copy(this)}}export{W as C,ht as E,f as O,lt as t};
//# sourceMappingURL=Ellipsoid-BKsGN9dG.js.map
